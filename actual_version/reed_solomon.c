#include "reed_solomon.h"
#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <string.h>
#include "datatypes.h"
#include "memory_tracker.h"
#include "galois_field.h"

raw_data get_factorised_generator(int t)
{
	raw_data factorised;
	factorised.length = 2 * t;
	factorised.data = (uint8_t*)alloc_named(factorised.length, "produce_generator_polynomial factorised");
	for(unsigned int i = 0; i < factorised.length; i++)
		factorised.data[i] = GF256(i+1);
	return factorised;
}

raw_data produce_generator_polynomial(int t)
{
	//start with factors like (x+GF256(1)(x+GF256(2)) etc
	//expand factors into each other
	raw_data factorised = get_factorised_generator(t);

	raw_data ret, aux;
	ret.length = 2 * t + 1;
	ret.data = (uint8_t*)alloc_named(ret.length, "produce_generator_polynomial ret");
	aux.length = 2 * t + 1;
	aux.data = (uint8_t*)alloc_named(aux.length, "produce_generator_polynomial aux");

	//ret and aux represent polynomials. The index represents the power and the
	//value represents the coefficient. aux is auxiliary for shift and add
	ret.data[0] = 1;
	for(unsigned int i = 1; i < ret.length; i++)
	{
		ret.data[i] = 0;
	}

	for(unsigned int i = 0; i < factorised.length; i++)
	{
		//multiply - put result in aux
		for(unsigned int j = 0; j < ret.length; j++)
			aux.data[j] = galois_multiply(ret.data[j], factorised.data[i]);

		//shift in place
		for(unsigned int j = ret.length - 1; j > 0; j--)
			ret.data[j] = ret.data[j-1];
		ret.data[0] = 0;

		//add
		for(unsigned int j = 0; j < ret.length; j++)
			ret.data[j] ^= aux.data[j];
	}

	dealloc(aux.data);
	dealloc(factorised.data);

	//reverse in place
	for(unsigned int i = 0; i < ret.length / 2; i++)
	{
		uint8_t tmp = ret.data[i];
		ret.data[i] = ret.data[ret.length - 1 - i];
		ret.data[ret.length - 1 - i] = tmp;
	}

  return ret;
}

//the encode function simply calculates the 2t parity checking symbols and returns T(x)
raw_data rs_encode(raw_data rd, int t)
{
  raw_data ret;

	ret.length = rd.length + 2 * t;
	ret.data = (uint8_t*)alloc_named(ret.length, "rs_encode ret");

	memcpy(ret.data, rd.data, rd.length);  //copy message
	for(unsigned int i = rd.length; i < ret.length; i++)
		ret.data[i] = 0;  //initialise parity symbols to 0

	raw_data g_x = produce_generator_polynomial(t);

	//do division here-
	for(unsigned int i = 0; i < ret.length - 2 * t; i++)
	{
		if(ret.data[i] == 0)  //multiply yields 0, so subtract doesn't change it
			continue;
		uint8_t multiplier = ret.data[i];
		for(unsigned int j = 0; j < g_x.length; j++)
			ret.data[i+j] ^= galois_multiply(g_x.data[j], multiplier);
	}

	//copy message back- as message symbols are unchanged in T(x)
	memcpy(ret.data, rd.data, rd.length);

	dealloc(g_x.data);
  return ret;
}

raw_data rs_decode(raw_data rd, int t, int* bit_error_count)
{
  raw_data ret;

	//resuse rs_encode to recalculate parity bits for received code
	rd.length -= 2 * t;
	raw_data re_encoded = rs_encode(rd, t);
	raw_data parity_bits;
	parity_bits.length = 2 * t;
	parity_bits.data = (uint8_t*)alloc_named(parity_bits.length, "rs_decode parity_bits");
	memcpy(parity_bits.data, re_encoded.data + re_encoded.length - 2 * t, 2 * t);
	dealloc(re_encoded.data);
	rd.length += 2 * t;

	//calculate syndromes: this is done by dividing the received polynomial by
	//all the factors of the generator polynomial. The simpler method is to
	//substitute the root.
 	raw_data syndromes = get_factorised_generator(t);
	//loop replaces factors with syndrome generated by that factor
	for(unsigned int i = 0; i < syndromes.length; i++)
	{
		//the accumulator is for adding the terms together
		uint8_t accumulator = 0;
		//calculating x^n by multiplying one at a time and doing a reverse loop
		//is more efficient than throwing away intermediate results
		uint8_t root_power_n = 1;
		for(int j = rd.length - 1; j >= 0; j--)
		{
			accumulator ^= galois_multiply(root_power_n, rd.data[j]);
			//root_power_n is multiplied after because first factor is x^0 = 1
			root_power_n = galois_multiply(root_power_n, syndromes.data[i]);
		}
		syndromes.data[i] = accumulator;
	}

	printf("syndromes:\n");
	for(unsigned int i = 0; i < syndromes.length; i++)
	{
		printf("%x\n", syndromes.data[i]);
	}











	ret.length = rd.length - 2 * t;
	ret.data = (uint8_t*)alloc_named(ret.length, "rs_decode ret");









  return ret;
}
